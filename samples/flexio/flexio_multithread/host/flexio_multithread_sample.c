/*
 * Copyright (c) 2023 NVIDIA CORPORATION & AFFILIATES, ALL RIGHTS RESERVED.
 *
 * This software product is a proprietary product of NVIDIA CORPORATION &
 * AFFILIATES (the "Company") and all right, title, and interest in and to the
 * software product, including all associated intellectual property rights, are
 * and shall remain exclusively with the Company.
 *
 * This software product is governed by the End User License Agreement
 * provided with the software product.
 *
 */

#include <malloc.h>
#include <unistd.h>
#include <stdlib.h>

#include <libflexio/flexio.h>
#include <doca_log.h>

#include "../flexio_multithread_common.h"

DOCA_LOG_REGISTER(FLEXIO_MULTITHREAD::SAMPLE);

#define IBV_DEVICE_NAME "mlx5_0"			/* Use mlx5_0 device */
#define NUM_OF_THREADS 8				/* Number of threads */
#define WORKER_BATCH_SIZE 4				/* Batch size per thread */
#define TIMEOUT_IN_SECONDS 4				/* Maximum time to wait for jobs to finish in seconds */
#define MR_BASE_ALIGNMENT 64				/* Memory alignment required for window buffers */

/* FlexIO application, generated by DPACC stub */
extern struct flexio_app *flexio_multithread_device;

/* RPC function to be called on the device */
extern flexio_func_t flexio_multithread_rpc;

/*
 * Run the FlexIO Multi Thread sample
 *
 * @argc [in]: Number of arguments
 * @argv [in]: Arguments
 * @return: DOCA_SUCCESS on success and DOCA_ERROR otherwise
 */
doca_error_t
flexio_multithread(int argc, char **argv)
{
	(void)argc;
	(void)argv;

	struct ibv_device **dev_list = NULL;		/* List of IB devices */
	struct ibv_device *dev = NULL;			/* Device to use */
	struct ibv_context *dev_ctx = NULL;		/* Device context */
	struct ibv_pd *pd = NULL;			/* Protection domain */

	struct flexio_cmdq_attr cmdq_fattr;		/* FlexIO command queue attributes */
	struct flexio_cmdq *cmd_q = NULL;		/* FlexIO command queue */
	struct flexio_window *flexio_window = NULL;	/* FlexIO window */
	struct flexio_process *flexio_process = NULL;	/* FlexIO process */

	struct host_to_device_config *device_cfgs;	/* Device config */

	int ibv_list_idx = 0x0;				/* Index into device list */
	int mat_bsize = N * N * sizeof(int32_t);	/* Matrix size in bytes */
	int nr_jobs = N * N;				/* Total jobs */
	int timer;

	flexio_uintptr_t device_cfg_ptr = 0x0;		/* Device config pointer device address */
	flexio_uintptr_t mat_a_daddr = 0x0;		/* Pointer to the first matrix */
	flexio_uintptr_t mat_b_daddr = 0x0;		/* Pointer to the second matrix */

	flexio_status ret = FLEXIO_STATUS_SUCCESS;	/* Return value */
	doca_error_t result = DOCA_SUCCESS;
	int i, j, job_idx;				/* Loop indices */

	int32_t mat_a[N][N] = { { 1, 1, 1, 1, 1 },
			    { 2, 2, 2, 2, 2 },
			    { 3, 3, 3, 3, 3 },
			    { 4, 4, 4, 4, 4 },
			    { 5, 5, 5, 5, 5 } };

	int32_t mat_b[N][N] = { { 1, 2, 3, 4, 5 },
			    { 1, 2, 3, 4, 5 },
			    { 1, 2, 3, 4, 5 },
			    { 1, 2, 3, 4, 5 },
			    { 1, 2, 3, 4, 5 } };
	struct ibv_mr *mat_c_mr = NULL;			/* Matrix C Memory Region */

	/* Mat c is the result matrix, this memory will reside in the HOST memory space,
	 * each thread will be able to write directly to this matrix using FlexIO Window.
	 */
	int32_t *mat_c;

	/* Allocate memory for result matrix, 64B alignment  */
	mat_bsize = mat_bsize + (MR_BASE_ALIGNMENT - 1);
	mat_bsize -= mat_bsize % MR_BASE_ALIGNMENT;
	if (posix_memalign((void *) &mat_c, MR_BASE_ALIGNMENT, mat_bsize) != 0) {
		DOCA_LOG_ERR("Failed to allocate memory");
		return DOCA_ERROR_NO_MEMORY;
	}
	memset(mat_c, 0, mat_bsize);

	device_cfgs = calloc(nr_jobs, sizeof(*device_cfgs));
	if (device_cfgs == NULL) {
		free(mat_c);
		DOCA_LOG_ERR("Failed to allocate memory");
		return DOCA_ERROR_NO_MEMORY;
	}

	/* Get list of available IB devices */
	dev_list = ibv_get_device_list(NULL);

	if (dev_list == NULL) {
		DOCA_LOG_ERR("Failed to get IB device list");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	/* Find the device we want to use */
	for (ibv_list_idx = 0; dev_list[ibv_list_idx] != NULL; ibv_list_idx++) {
		if (strcmp(dev_list[ibv_list_idx]->name, IBV_DEVICE_NAME) == 0) {
			dev = dev_list[ibv_list_idx];
			break;
		}
	}

	if (dev == NULL) {
		DOCA_LOG_ERR("Failed to find device %s", IBV_DEVICE_NAME);
		result = DOCA_ERROR_NOT_FOUND;
		goto cleanup;
	}

	/* Create device context */
	dev_ctx = ibv_open_device(dev);
	if (dev_ctx == NULL) {
		DOCA_LOG_ERR("Failed to open device %s", IBV_DEVICE_NAME);
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	/* Allocate Protection Domain */
	pd = ibv_alloc_pd(dev_ctx);
	if (pd == NULL) {
		DOCA_LOG_ERR("Failed to allocate PD");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	/* Register Memory buffers to be used by the device */
	mat_c_mr = ibv_reg_mr(pd, mat_c, mat_bsize, IBV_ACCESS_LOCAL_WRITE);
	if (mat_c_mr == NULL) {
		DOCA_LOG_ERR("Failed to register Matrix C MR");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	ret = flexio_process_create(dev_ctx, flexio_multithread_device, NULL, &flexio_process);
	if (ret != FLEXIO_STATUS_SUCCESS) {
		DOCA_LOG_ERR("Failed to create FlexIO process");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	/* Create FlexIO Window */
	ret = flexio_window_create(flexio_process, pd, &flexio_window);
	if (ret != FLEXIO_STATUS_SUCCESS) {
		DOCA_LOG_ERR("Failed to create FlexIO window");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	/* Copy Matrix A to device */
	ret = flexio_copy_from_host(flexio_process, mat_a, mat_bsize,
					&mat_a_daddr);
	if (ret != FLEXIO_STATUS_SUCCESS) {
		DOCA_LOG_ERR("Failed to copy Matrix A to device");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	/* Copy Matrix B to device */
	ret = flexio_copy_from_host(flexio_process, mat_b, mat_bsize,
					&mat_b_daddr);
	if (ret != FLEXIO_STATUS_SUCCESS) {
		DOCA_LOG_ERR("Failed to copy Matrix B to device");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	/* Command Queue depth equals workers * batch_size,
	 * the queue depth determines the maximum number of jobs that can be submitted to the command queue.
	 */
	cmdq_fattr.workers = NUM_OF_THREADS;
	cmdq_fattr.batch_size = WORKER_BATCH_SIZE;
	cmdq_fattr.state = FLEXIO_CMDQ_STATE_PENDING;

	ret = flexio_cmdq_create(flexio_process, &cmdq_fattr, &cmd_q);
	if (ret != FLEXIO_STATUS_SUCCESS) {
		DOCA_LOG_ERR("Failed to create FlexIO command queue");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	/* Prepare all jobs, each job is responsible for one cell in the result matrix */
	for (i = 0; i < N; i++) {
		for (j = 0; j < N; j++) {
			job_idx = i*N + j;

			device_cfgs[job_idx].mkey = mat_c_mr->lkey;
			device_cfgs[job_idx].window_id = flexio_window_get_id(flexio_window);
			device_cfgs[job_idx].haddr = (uint64_t)mat_c;
			device_cfgs[job_idx].mat_a_daddr = mat_a_daddr;
			device_cfgs[job_idx].mat_b_daddr = mat_b_daddr;
			device_cfgs[job_idx].row = i;
			device_cfgs[job_idx].col = j;
		}
	}

	/* Copy configurations to device memory */
	ret = flexio_copy_from_host(flexio_process, device_cfgs, nr_jobs * sizeof(*device_cfgs), &device_cfg_ptr);
	if (ret != FLEXIO_STATUS_SUCCESS) {
		DOCA_LOG_ERR("Failed to copy memory to device");
		goto cleanup;
	}

	/* Submit jobs */
	for (i = 0; i < N; i++) {
		for (j = 0; j < N; j++) {
			flexio_uintptr_t next_ptr =  device_cfg_ptr + (i*N+j)*sizeof(*device_cfgs);

			ret = flexio_cmdq_task_add(cmd_q, flexio_multithread_rpc, next_ptr);
			if (ret != FLEXIO_STATUS_SUCCESS) {
				DOCA_LOG_ERR("Failed to add task to command queue");
				result = DOCA_ERROR_DRIVER;
				goto cleanup;
			}
		}
	}

	/* Start the command queue */
	flexio_cmdq_state_running(cmd_q);

	/* Wait for all jobs to complete */
	timer = 0;

	while (!flexio_cmdq_is_empty(cmd_q)) {
		sleep(1);
		if (timer++ == TIMEOUT_IN_SECONDS) {
			DOCA_LOG_ERR("Timeout waiting for command queue to finish");
			result = DOCA_ERROR_TIME_OUT;
			goto cleanup;
		}
	}

	DOCA_LOG_INFO("Result matrix:");
	for (i = 0; i < N; i++) {
		for (j = 0; j < N; j++)
			printf("%d ", mat_c[i*N + j]);
		printf("\n");
	}

cleanup:

	if (mat_a_daddr != 0x0)
		flexio_buf_dev_free(flexio_process, mat_a_daddr);
	if (mat_b_daddr != 0x0)
		flexio_buf_dev_free(flexio_process, mat_b_daddr);
	if (device_cfg_ptr != 0x0)
		flexio_buf_dev_free(flexio_process, device_cfg_ptr);
	if (cmd_q != NULL)
		flexio_cmdq_destroy(cmd_q);
	if (flexio_window != NULL)
		flexio_window_destroy(flexio_window);
	if (pd != NULL)
		ibv_dealloc_pd(pd);
	if (flexio_process != NULL)
		flexio_process_destroy(flexio_process);
	if (pd != NULL)
		ibv_dealloc_pd(pd);
	if (dev_ctx != NULL)
		ibv_close_device(dev_ctx);
	if (dev_list != NULL)
		ibv_free_device_list(dev_list);
	if (mat_c != NULL)
		free(mat_c);
	if (device_cfgs != NULL)
		free(device_cfgs);
	return result;
}
