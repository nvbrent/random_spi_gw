/*
 * Copyright (c) 2022-2023 NVIDIA CORPORATION & AFFILIATES, ALL RIGHTS RESERVED.
 *
 * This software product is a proprietary product of NVIDIA CORPORATION &
 * AFFILIATES (the "Company") and all right, title, and interest in and to the
 * software product, including all associated intellectual property rights, are
 * and shall remain exclusively with the Company.
 *
 * This software product is governed by the End User License Agreement
 * provided with the software product.
 *
 */

#include <unistd.h>

#include <libflexio/flexio.h>
#include <doca_log.h>

#include "../flexio_window_common.h"

DOCA_LOG_REGISTER(FLEXIO_WINDOW::SAMPLE);

#define IBV_DEVICE_NAME "mlx5_0"			/* Use mlx5_0 device */
#define MR_BASE_ALIGNMENT 64				/* Memory alignment required for window buffers */

/* FlexIO application, generated by DPACC stub */
extern struct flexio_app *flexio_window_device;

/* RPC function to be called on the device */
extern flexio_func_t flexio_window_rpc;

/*
 * Run the FlexIO RPC sample
 *
 * @argc [in]: Number of arguments
 * @argv [in]: Arguments
 * @return: DOCA_SUCCESS on success and DOCA_ERROR otherwise
 */
doca_error_t
flexio_window(int argc, char **argv)
{
	(void)argc;
	(void)argv;

	struct ibv_device **dev_list = NULL;		/* List of IB devices */
	struct ibv_device *dev = NULL;			/* Device to use */
	struct ibv_context *dev_ctx = NULL;		/* Device context */
	struct ibv_pd *pd = NULL;			/* Protection domain */
	struct ibv_mr *mr = NULL;			/* Memory region */
	struct mlx5dv_devx_uar *devx_uar = NULL;	/*  UAR */

	struct flexio_window *flexio_window = NULL;	/* FlexIO window */
	struct flexio_uar *flexio_uar = NULL;		/* FlexIO UAR */
	struct flexio_process *flexio_process = NULL;	/* FlexIO process */
	flexio_uintptr_t device_cfg_p = 0;		/* Device config address */
	flexio_status ret = FLEXIO_STATUS_SUCCESS;	/* Return value */

	struct host_to_device_config device_cfg = {0};	/* Device config */
	char *host_buffer = NULL;			/* Host buffer */
	int ibv_list_idx = 0x0;				/* Index into device list */
	uint64_t rpc_call_result;			/* RPC call result */
	doca_error_t result = DOCA_SUCCESS;
	int host_buffer_bsize;

	/* Get list of available IB devices */
	dev_list = ibv_get_device_list(NULL);

	if (dev_list == NULL) {
		DOCA_LOG_ERR("Failed to get IB device list");
		return DOCA_ERROR_DRIVER;
	}

	/* Find the device we want to use */
	for (ibv_list_idx = 0; dev_list[ibv_list_idx] != NULL; ibv_list_idx++) {
		if (strcmp(dev_list[ibv_list_idx]->name, IBV_DEVICE_NAME) == 0) {
			dev = dev_list[ibv_list_idx];
			break;
		}
	}

	if (dev == NULL) {
		DOCA_LOG_ERR("Failed to find device %s", IBV_DEVICE_NAME);
		result = DOCA_ERROR_NOT_FOUND;
		goto cleanup;
	}

	/* Create device context */
	dev_ctx = ibv_open_device(dev);
	if (dev_ctx == NULL) {
		DOCA_LOG_ERR("Failed to open device %s", IBV_DEVICE_NAME);
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	pd = ibv_alloc_pd(dev_ctx);
	if (pd == NULL) {
		DOCA_LOG_ERR("Failed to allocate PD");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	host_buffer_bsize = HOST_BUFFER_SIZE + (MR_BASE_ALIGNMENT - 1);
	host_buffer_bsize -= host_buffer_bsize % MR_BASE_ALIGNMENT;
	posix_memalign((void **)&host_buffer, MR_BASE_ALIGNMENT, host_buffer_bsize);
	if (host_buffer == NULL) {
		DOCA_LOG_ERR("Failed to allocate host buffer");
		result = DOCA_ERROR_NO_MEMORY;
		goto cleanup;
	}

	memset(host_buffer, 0, HOST_BUFFER_SIZE);

	mr = ibv_reg_mr(pd, host_buffer, HOST_BUFFER_SIZE, IBV_ACCESS_LOCAL_WRITE);
	if (mr == NULL) {
		DOCA_LOG_ERR("Failed to register MR");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	devx_uar = mlx5dv_devx_alloc_uar(dev_ctx, MLX5DV_UAR_ALLOC_TYPE_NC);
	if (devx_uar == NULL) {
		DOCA_LOG_ERR("Failed to allocate UAR");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	ret = flexio_process_create(dev_ctx, flexio_window_device, NULL, &flexio_process);
	if (ret != FLEXIO_STATUS_SUCCESS) {
		DOCA_LOG_ERR("Failed to create FlexIO process");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	ret = flexio_uar_create(flexio_process, devx_uar, &flexio_uar);
	if (ret != FLEXIO_STATUS_SUCCESS) {
		DOCA_LOG_ERR("Failed to create FlexIO UAR");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	ret = flexio_window_create(flexio_process, pd, &flexio_window);
	if (ret != FLEXIO_STATUS_SUCCESS) {
		DOCA_LOG_ERR("Failed to create FlexIO window");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	device_cfg.window_id = flexio_window_get_id(flexio_window);
	device_cfg.mkey = mr->lkey;
	device_cfg.haddr = (uintptr_t) host_buffer;
	ret = flexio_copy_from_host(flexio_process, &device_cfg, sizeof(device_cfg), &device_cfg_p);
	if (ret != FLEXIO_STATUS_SUCCESS) {
		DOCA_LOG_ERR("Failed to copy device config to device");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	/* Prepare host buffer */
	strncpy(host_buffer, "FlexIO Window Sample", HOST_BUFFER_SIZE);

	ret = flexio_process_call(flexio_process, &flexio_window_rpc, &rpc_call_result, (uint64_t)device_cfg_p);
	if (ret != FLEXIO_STATUS_SUCCESS) {
		DOCA_LOG_ERR("Failed to call flexio_window_rpc function on the device");
		result = DOCA_ERROR_DRIVER;
		goto cleanup;
	}

	if (rpc_call_result != 0)
		DOCA_LOG_ERR("flexio_window_rpc() function on the device failed");
	else
		DOCA_LOG_INFO("Host buffer: %s", host_buffer);

cleanup:
	if (device_cfg_p != 0x0)
		flexio_buf_dev_free(flexio_process, device_cfg_p);
	if (flexio_window != NULL)
		flexio_window_destroy(flexio_window);
	if (flexio_uar != NULL)
		flexio_uar_destroy(flexio_uar);
	if (flexio_process != NULL)
		flexio_process_destroy(flexio_process);
	if (devx_uar != NULL)
		mlx5dv_devx_free_uar(devx_uar);
	if (mr != NULL)
		ibv_dereg_mr(mr);
	if (host_buffer != NULL)
		free(host_buffer);
	if (pd != NULL)
		ibv_dealloc_pd(pd);
	if (dev_ctx != NULL)
		ibv_close_device(dev_ctx);
	if (dev_list != NULL)
		ibv_free_device_list(dev_list);
	return result;
}
